// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

namespace Ubiquity.NET.SrcGeneration.CSharp
{
    /// <summary>Utility extensions for an <see cref="IndentedTextWriter"/> specific to the C# language</summary>
    [SuppressMessage( "Performance", "CA1822:Mark members as static", Justification = "extension" )]
    [SuppressMessage( "Design", "CA1034:Nested types should not be visible", Justification = "extension" )]
    public static class IndentedTextWriterExtensions
    {
        /// <summary>Writes a standard <c>auto-generated</c> comment block</summary>
        /// <param name="self">Writer to apply extension method to</param>
        /// <param name="toolName">Name of the generating tool (included in comment)</param>
        /// <param name="toolVersion">Version of the tool (included in comment)</param>
        /// <param name="source">Source of the generated file [Default: null]</param>
        /// <param name="writeClosingNewLine">Indicates if the scope is closed with a newline</param>
        public static void WriteAutoGeneratedComment(
            this IndentedTextWriter self,
            string toolName,
            string toolVersion,
            string? source = null,
            bool writeClosingNewLine = false
            )
        {
#if NET8_0_OR_GREATER
            ArgumentNullException.ThrowIfNull( self );
#else
            PolyFillExceptionValidators.ThrowIfNull( self );
#endif

            using var scope = self.WriteAutoGeneratedCommentBlock(toolName, toolVersion, writeClosingNewLine: writeClosingNewLine);

            if(!string.IsNullOrWhiteSpace( source ))
            {
                self.WriteCommentLine( $"    From: {source}" );
            }

            self.WriteEmptyCommentLine();
        }

        /// <summary>Writes a standard <c>auto-generated</c> comment block returning the scope for additional contents</summary>
        /// <param name="self">Writer to apply extension method to</param>
        /// <param name="toolName">Name of the generating tool (included in comment)</param>
        /// <param name="toolVersion">Version of the tool (included in comment)</param>
        /// <param name="writeClosingNewLine">Indicates if the scope is closed with a newline</param>
        /// <returns>Disposable scope for the namespace (closes the scope on dispose)</returns>
        /// <remarks>
        /// To remain syntactically valid all lines written to the writer within this block
        /// <em><b>MUST</b></em> include a leading "//" (this does NOT alter the prefix requirement
        /// for the writer). The resulting scope is NOT indented.
        /// </remarks>
        /// <seealso cref="TextWriterExtensions.WriteCommentLines(TextWriter, IEnumerable{string})"/>
        /// <seealso cref="TextWriterExtensions.WriteCommentLines(TextWriter, string)"/>
        /// <seealso cref="TextWriterExtensions.WriteCommentLine(TextWriter, string)"/>
        public static IDisposable WriteAutoGeneratedCommentBlock( this IndentedTextWriter self, string toolName, string toolVersion, bool writeClosingNewLine = false )
        {
#if NET8_0_OR_GREATER
            ArgumentNullException.ThrowIfNull( self );
            ArgumentException.ThrowIfNullOrWhiteSpace( toolName );
            ArgumentException.ThrowIfNullOrWhiteSpace( toolVersion );
#else
            PolyFillExceptionValidators.ThrowIfNull( self );
            PolyFillExceptionValidators.ThrowIfNullOrWhiteSpace( toolName );
            PolyFillExceptionValidators.ThrowIfNullOrWhiteSpace( toolVersion );
#endif

            string open = $"""
            // ------------------------------------------------------------------------------
            // <auto-generated>
            //     This code was generated by a tool.
            //     {toolName} [{toolVersion}]
            """;

            string close = """
            //     Changes to this file may cause incorrect behavior and will be lost if
            //     the code is regenerated.
            // </auto-generated>
            // ------------------------------------------------------------------------------
            """;
            return self.Block( open, close, indented: false, writeClosingNewLine: writeClosingNewLine );
        }

        /// <summary>Writes a Namespace declaration scope</summary>
        /// <param name="self">Writer to apply extension method to</param>
        /// <param name="namespaceName">Name of the namespace</param>
        /// <param name="writeClosingNewLine">Indicates if the scope is closed with a newline</param>
        /// <returns>Disposable scope for the namespace (closes the scope on dispose)</returns>
        public static IDisposable Namespace( this IndentedTextWriter self, string namespaceName, bool writeClosingNewLine = false )
        {
#if NET8_0_OR_GREATER
            ArgumentNullException.ThrowIfNull( self );
            ArgumentException.ThrowIfNullOrWhiteSpace(namespaceName);
#else
            PolyFillExceptionValidators.ThrowIfNull( self );
            PolyFillExceptionValidators.ThrowIfNullOrWhiteSpace(namespaceName);
#endif

            return self.Scope( $"namespace {namespaceName}", writeClosingNewLine: writeClosingNewLine );
        }

        /// <summary>Writes a C# struct declaration</summary>
        /// <param name="self">Writer to apply extension method to</param>
        /// <param name="access">Access (prefix) for the struct declaration</param>
        /// <param name="structName">name of the structure</param>
        /// <param name="writeClosingNewLine">Indicates if the scope is closed with a newline</param>
        /// <returns>Disposable scope that closes the struct declaration on <see cref="IDisposable.Dispose"/></returns>
        public static IDisposable Struct( this IndentedTextWriter self, string? access, string structName, bool writeClosingNewLine = false )
        {
#if NET8_0_OR_GREATER
            ArgumentException.ThrowIfNullOrWhiteSpace( structName );
#else
            PolyFillExceptionValidators.ThrowIfNullOrWhiteSpace( structName );
#endif

            access ??= string.Empty;
            return self.Scope( $"{access} struct {structName}", writeClosingNewLine: writeClosingNewLine );
        }

        /// <summary>Write an "unsafe" region as a scope</summary>
        /// <param name="self">Writer to apply extension method to</param>
        /// <param name="writeClosingNewLine">Indicates if the scope is closed with a newline</param>
        /// <returns>Disposable scope that closes the region declaration on <see cref="IDisposable.Dispose"/></returns>
        public static IDisposable UnsafeScope( this IndentedTextWriter self, bool writeClosingNewLine = false )
        {
            return self.Scope( "unsafe", writeClosingNewLine: writeClosingNewLine );
        }

        /// <summary>Write a scope as a region</summary>
        /// <param name="self">Writer to apply extension method to</param>
        /// <param name="leadingLine">Leading line of the scope, if any.</param>
        /// <param name="writeClosingNewLine">Indicates if the scope is closed with a newline</param>
        /// <returns>Disposable scope that closes the struct declaration on <see cref="IDisposable.Dispose"/></returns>
        /// <remarks>
        /// <para><paramref name="leadingLine"/> is written on a line of it's own then <see cref="CSharpLanguage.ScopeOpen"/>
        /// is written and the indentation is pushed and the returned disposer will outdent and write
        /// <see cref="CSharpLanguage.ScopeClose"/>. Thus any values written until the return is disposed is indented
        /// automatically.</para>
        /// <para>
        /// If <paramref name="writeClosingNewLine"/> is <see langword="true"/> then the scope is closed with a newline and
        /// indentation. Otherwise, no newline is written. This allows for additional comments etc.. on the closing. For compatibility
        /// the default is <see langword="false"/> to NOT generate a newline. callers can specify a new line by setting
        /// <paramref name="writeClosingNewLine"/> to <see langword="true"/>.
        /// </para>
        /// </remarks>
        public static IDisposable Scope( this IndentedTextWriter self, string? leadingLine = null, bool writeClosingNewLine = false )
        {
            return self.Block( CSharpLanguage.ScopeOpen, CSharpLanguage.ScopeClose, leadingLine, writeClosingNewLine: writeClosingNewLine );
        }

        /// <summary>Writes <paramref name="txt"/> as a multi-line comment</summary>
        /// <param name="self">Writer to apply extension method to</param>
        /// <param name="txt">Text of the comment</param>
        /// <param name="writeClosingNewLine">Indicates if the scope is closed with a newline</param>
        /// <remarks>If <paramref name="txt"/> is <see langword="null"/>, empty, or all whitespace then this is a NOP</remarks>
        public static void MultiLineComment( this IndentedTextWriter self, string? txt, bool writeClosingNewLine = false )
        {
#if NET6_0_OR_GREATER
            ArgumentNullException.ThrowIfNull( self );
#else
            PolyFillExceptionValidators.ThrowIfNull( self );
#endif

            if(string.IsNullOrWhiteSpace(txt))
            {
                return;
            }

            string[] lines = [ .. txt!.GetCommentLines() ];
            if(lines.Length > 0)
            {
                using(self.Block( "/*", "*/", writeClosingNewLine: writeClosingNewLine ))
                {
                    foreach(string line in lines)
                    {
                        self.WriteLine( line );
                    }
                }
            }
        }

        /// <summary>Writes a C# class scope</summary>
        /// <param name="self">Writer to apply extension method to</param>
        /// <param name="access">access modifier (prefix) for the declaration</param>
        /// <param name="className">Name of the class to generate</param>
        /// <param name="writeClosingNewLine">Indicates if the scope is closed with a newline</param>
        /// <returns>Disposable scope that closes the class declaration on <see cref="IDisposable.Dispose"/></returns>
        public static IDisposable Class( this IndentedTextWriter self, string? access, string className, bool writeClosingNewLine = false )
        {
#if NET8_0_OR_GREATER
            ArgumentException.ThrowIfNullOrWhiteSpace( className );
#else
            PolyFillExceptionValidators.ThrowIfNullOrWhiteSpace( className );
#endif

            access ??= string.Empty;
            return self.Scope( $"{access} class {className}", writeClosingNewLine: writeClosingNewLine );
        }
    }
}
