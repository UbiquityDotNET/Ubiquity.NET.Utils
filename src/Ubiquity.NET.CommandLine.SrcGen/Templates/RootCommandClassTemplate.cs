// Copyright (c) Ubiquity.NET Contributors. All rights reserved.
// Licensed under the Apache-2.0 WITH LLVM-exception license. See the LICENSE.md file in the project root for full license information.

using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;

using Microsoft.CodeAnalysis.CSharp;

namespace Ubiquity.NET.CommandLine.SrcGen.Templates
{
    internal class RootCommandClassTemplate
        : ISourceGenTemplate
    {
        internal RootCommandClassTemplate( RootCommandInfo info )
        {
            Info = info;

            // filter out properties that don't have any relevant attributes
            Properties = [ .. from prop in info.Properties
                              where prop.Attributes.Count > 0
                              select prop
                         ];
        }

        public RootCommandInfo Info { get; }

        public ImmutableArray<PropertyInfo> Properties { get; }

        public string ClassName => Info.TargetName.SimpleName;

        public string Namespace => Info.TargetName.Namespace;

        [SuppressMessage("Style", "IDE0063:Use simple 'using' statement", Justification = "Scoping intent is clearer without them")]
        public SourceText GenerateText( )
        {
            var srcTxt = new StringBuilderText(Encoding.UTF8);
            using var simpleWriter = srcTxt.CreateWriter();
            using var writer = new IndentedTextWriter(simpleWriter);

            writer.WriteAutoGeneratedComment(ToolInfo.Name, ToolInfo.Version);
            writer.WriteEmptyLine();

            writer.WriteLine($"using static {Constants.SymbolValidationExtensions:G};");
            writer.WriteEmptyLine();

            using (writer.Namespace(Namespace, writeClosingNewLine: true ))
            {
                writer.WriteLine("internal partial class {0}", ClassName);
                using (var scope = writer.PushIndent())
                {
                    writer.WriteLine($": {Constants.IRootCommandBuilderWithSettings:G}");
                    writer.WriteLine($", {Constants.ICommandBinder:G}<{ClassName}>");
                }

                using (var typeScope = writer.Scope(writeClosingNewLine: true))
                {
                    WriteSettingsProperty(writer);
                    writer.WriteEmptyLine();

                    WriteBindMethod(writer);
                    writer.WriteEmptyLine();

                    WriteBuildCommandMethod(writer);
                }

                writer.WriteEmptyLine();
                WriteDescriptors( writer );
            }

            writer.Flush();
            return srcTxt;
        }

        private void WriteBindMethod( IndentedTextWriter writer )
        {
            using var bindMethodScope = writer.Scope($"public static {ClassName} Bind( {Constants.ParseResult:G} parseResult )", writeClosingNewLine: true);
            using (var allocationScope = writer.Scope("return new()"))
            {
                foreach (PropertyInfo info in Properties)
                {
                    string methodName = info.IsRequired ? "GetRequiredValue" : "GetValue";
                    writer.WriteLine($"{info.SimpleName} = parseResult.{methodName}( Descriptors.{info.SimpleName} ),");
                }
            }

            writer.WriteLine(";");
        }

        private void WriteBuildCommandMethod( IndentedTextWriter writer )
        {
            string methodDecl = $"public static {Constants.AppControlledDefaultsRootCommand:G} Build( )";
            using var buildRootCommandScope = writer.Scope(methodDecl, writeClosingNewLine: true);

            string returnLine = Info.Description.HasValue
                ? $"return new {Constants.AppControlledDefaultsRootCommand:G}( Settings, \"{Info.Description.Value}\" )"
                : $"return new {Constants.AppControlledDefaultsRootCommand:G}( Settings )";

            using (var allocationScope = writer.Scope(returnLine))
            {
                foreach (PropertyInfo property in Properties)
                {
                    writer.WriteLine($"Descriptors.{property.SimpleName},");
                }
            }

            writer.WriteLine(";");
        }

        private void WriteSettingsProperty( IndentedTextWriter writer )
        {
            writer.Write($"public static {Constants.CommandLineSettings:G} Settings => new()");
            if (Info.HasSettings)
            {
                writer.WriteLine();
                using var offset = writer.PushIndent();
                using var initScope = writer.Scope(writeClosingNewLine: false);
                {
                    if (Info.ShowHelpOnErrors.HasValue)
                    {
                        writer.WriteLine("ShowHelpOnErrors = {0},", CSharpLanguage.AsLiteral( Info.ShowHelpOnErrors.Value ));
                    }

                    if (Info.ShowTypoCorrections.HasValue)
                    {
                        writer.WriteLine("ShowTypoCorrections = {0},", CSharpLanguage.AsLiteral( Info.ShowTypoCorrections.Value ));
                    }

                    if (Info.EnablePosixBundling.HasValue)
                    {
                        writer.WriteLine("EnablePosixBundling = {0},", CSharpLanguage.AsLiteral( Info.EnablePosixBundling.Value ));
                    }

                    if (Info.DefaultOptions.HasValue)
                    {
                        writer.WriteLine("DefaultOptions = {0},", Info.DefaultOptions.Value);
                    }

                    if (Info.DefaultDirectives.HasValue)
                    {
                        writer.WriteLine("DefaultDirectives = {0},", Info.DefaultDirectives.Value);
                    }

                    // TODO: ResponseFileTokenReplacer
                }
            }

            writer.WriteLine(";");
        }

        private void WriteDescriptors( IndentedTextWriter writer )
        {
            using var descriptorScope = writer.Class("file static", "Descriptors", writeClosingNewLine: true);
            for (int i = 0; i < Properties.Length; ++i)
            {
                var property = Properties[i];
                if (property.Attributes.TryGetValue(Constants.OptionAttribute, out EquatableAttributeData? attr))
                {
                    WriteOptionDescriptor(writer, property, attr);
                }

                // if not the last property generate an empty line between entries
                if (i != Properties.Length - 1)
                {
                    writer.WriteEmptyLine();
                }
            }
        }

        private static void WriteOptionDescriptor( IndentedTextWriter writer, PropertyInfo property, OptionInfo info )
        {
            // NOP if the attribute does not contain valid data.
            // Analyzer should detect that case and complain.
            if (!info.IsValid)
            {
                Debug.WriteLine("!!Skipping Invalid OptionInfo!!");
                return;
            }

            string propTypeName = $"{Constants.Option:G}<{property.TypeName:AG}>";
            writer.WriteLine($"internal static readonly {propTypeName} {property.SimpleName}");
            using (writer.PushIndent()) // property initializer indentation
            {
                // Aliases are only set via the constructor
                writer.Write( $"= new {propTypeName}({CSharpLanguage.AsLiteral( info.Name )}" );
                var aliases = info.Aliases;
                if(aliases.HasValue)
                {
                    writer.Write( ", " );
                    writer.Write( string.Join( ", ", aliases.Value.Select( CSharpLanguage.AsLiteral ) ) );
                }

                writer.WriteLine( ')' );
                using(var valueInitializerScope = writer.Scope())
                {
                    // This, intentionally, does not take into account any "default" values
                    // The source generator should remain ignorant of the default values for the
                    // generated source OR the attributes. If the setting is present the value is
                    // used, even if it's the same as a default. This keeps the generator independent
                    // of such details; allowing them to change without changing the generator!
                    var helpName = info.HelpName;
                    if(helpName.HasValue)
                    {
                        writer.WriteLine( "HelpName = {0},", CSharpLanguage.AsLiteral( helpName.Value ) );
                    }

                    var description = info.Description;
                    if(description.HasValue)
                    {
                        writer.WriteLine( "Description = {0},", CSharpLanguage.AsLiteral( description.Value ) );
                    }

                    var required = info.Required;
                    if(required.HasValue)
                    {
                        writer.WriteLine( "Required = {0},", CSharpLanguage.AsLiteral( required.Value ) );
                    }

                    var hidden = info.Hidden;
                    if(hidden.HasValue)
                    {
                        writer.WriteLine( "Hidden = {0},", CSharpLanguage.AsLiteral( hidden.Value ) );
                    }

                    var arity = info.Arity;
                    if(arity.HasValue)
                    {
                        // while there are static instance values for convenience
                        // there is no way to know the *OrMore variants as the
                        // max value used for them is a private const int. Besides,
                        // that the type is a struct and therefore use of those results
                        // in a copy anyway. Thus, this just emits construction of the
                        // correct type.

                        (int min, int max) = arity.Value;
                        writer.WriteLine( $"Arity = new {Constants.ArgumentArity:G}({min}, {max})," );
                    }
                }

                // Handle the indentation for validation, it isn't a full indentation scope, it's just alignment
                string extraSpace=string.Empty;

                // ANALYZER VALIDATION: These are mutually exclusive.
                // Generator ignores the file validation attribute if the folder validation attribute
                // is present. Analyzer should generate a diagnostic.
                if(!WriteFolderValidation( writer, property, ref extraSpace ))
                {
                    WriteFileValidation( writer, property, ref extraSpace );
                }

                // TODO: DefaultValueFactory
                // TODO: Custom validators...

                writer.WriteLine( ";" );
            }
        }

        private static bool WriteFolderValidation( IndentedTextWriter writer, PropertyInfo property, ref string extraSpace )
        {
            if(!property.Attributes.TryGetValue( Constants.FolderValidationAttribute, out var folderValidationAttrib))
            {
                return false;
            }

            if((property.TypeName == Constants.DirectoryInfo) && !folderValidationAttrib.ConstructorArguments[ 0 ].IsNull)
            {
                int enumVal = (int)folderValidationAttrib.ConstructorArguments[ 0 ].Value!;
                switch((FolderValidation)enumVal)
                {
                case FolderValidation.CreateIfNotExist:
                    if(extraSpace.Length > 0)
                    {
                        writer.WriteLine();
                    }

                    writer.Write( $"{extraSpace}.EnsureFolder()" );
                    extraSpace = " ";

                    break;

                case FolderValidation.ExistingOnly:
                    if(extraSpace.Length > 0)
                    {
                        writer.WriteLine();
                    }

                    writer.Write( $"{extraSpace}.AcceptExistingFolderOnly()" );
                    extraSpace = " ";
                    break;

                case FolderValidation.None:
                default:
                    break;
                }
            }

            return true;
        }

        private static void WriteFileValidation( IndentedTextWriter writer, PropertyInfo property, ref string extraSpace )
        {
            if(property.Attributes.TryGetValue( Constants.FileValidationAttribute, out var fileValidationAttrib )
            && (property.TypeName == Constants.FileInfo)
            && !fileValidationAttrib.ConstructorArguments[ 0 ].IsNull
            )
            {
                int enumVal = (int)fileValidationAttrib.ConstructorArguments[ 0 ].Value!;
                switch((FileValidation)enumVal)
                {
                case FileValidation.ExistingOnly:
                    if(extraSpace.Length > 0)
                    {
                        writer.WriteLine();
                    }

                    writer.Write( $"{extraSpace}.AcceptExistingFileOnly()" );
                    extraSpace = " ";
                    break;

                case FileValidation.None:
                default:
                    break;
                }
            }
        }
    }
}
